name: Sync Fork from Upstream

on:
  schedule:
    # 每天北京时间 03:00 和 15:00 自动运行（UTC 时间转换）
    - cron: '0 19 * * *'  # UTC 19:00 = 北京时间 次日 03:00
    - cron: '0 7 * * *'   # UTC 07:00 = 北京时间 当天 15:00
  workflow_dispatch:
    inputs:
      upstream_repos:
        description: |
          要同步的源仓库 (格式: owner/repo)
          多个用逗号分隔，留空为当前仓库
          输入 'all' 使用默认配置
        required: false
        default: 'all'
      target_repos:
        description: |
          要同步到的目标 Fork 仓库 (格式: your-username/repo)
          多个用逗号分隔，留空为当前仓库
          输入 'all' 同步所有已 Fork 仓库（需与上游仓库对应）
        required: false
        default: 'all'
      force_sync:
        description: '强制同步（忽略时间检查）'
        type: boolean
        default: false

# 授予基础权限（核心权限由 PAT 提供）
permissions:
  contents: write
  pull-requests: read

jobs:
  sync-multi-repos-branches:
    runs-on: ubuntu-latest
    steps:
      # 步骤1：配置 Git 身份（用于提交同步记录）
      - name: Configure Git user
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # 步骤2：定义默认上游仓库和目标仓库（核心配置：你的所有仓库）
      - name: Set default repos (all)
        id: set-repos
        run: |
          # 配置默认上游仓库（多个用逗号分隔，对应你的 Fork 源）
          DEFAULT_UPSTREAM="timeflysoon/OpenClash"
          # 配置默认目标仓库（你的所有 Fork 仓库，多个用逗号分隔）
          DEFAULT_TARGET="your-username/OpenClash,your-username/other-repo1"  # 替换为你的仓库
          
          # 处理上游仓库参数
          INPUT_UPSTREAM="${{ github.event.inputs.upstream_repos }}"
          if [[ "$INPUT_UPSTREAM" == "all" ]]; then
            UPSTREAM_REPOS="$DEFAULT_UPSTREAM"
          elif [[ -z "$INPUT_UPSTREAM" ]]; then
            UPSTREAM_REPOS="${{ github.repository }}"
          else
            UPSTREAM_REPOS="$INPUT_UPSTREAM"
          fi
          
          # 处理目标仓库参数
          INPUT_TARGET="${{ github.event.inputs.target_repos }}"
          if [[ "$INPUT_TARGET" == "all" ]]; then
            TARGET_REPOS="$DEFAULT_TARGET"
          elif [[ -z "$INPUT_TARGET" ]]; then
            TARGET_REPOS="${{ github.repository }}"
          else
            TARGET_REPOS="$INPUT_TARGET"
          fi
          
          # 输出到环境变量
          echo "UPSTREAM_REPOS=$UPSTREAM_REPOS" >> $GITHUB_ENV
          echo "TARGET_REPOS=$TARGET_REPOS" >> $GITHUB_ENV

      # 步骤3：循环同步所有目标仓库（基于 PAT 跨仓库权限）
      - name: Sync all branches for multi repos (cross-repo)
        env:
          # 引用配置的 Repository Secrets 中的 PAT（名称需与你配置的一致）
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          # 分割上游仓库和目标仓库列表（逗号分隔）
          IFS=',' read -ra UPSTREAM_LIST <<< "$UPSTREAM_REPOS"
          IFS=',' read -ra TARGET_LIST <<< "$TARGET_REPOS"
          
          # 循环遍历所有目标仓库（跨仓库核心逻辑）
          for TARGET in "${TARGET_LIST[@]}"; do
            TARGET=$(echo "$TARGET" | xargs)
            echo "======================================"
            echo "Starting to handle target repo: $TARGET"
            echo "======================================"
            
            # 1. 使用 PAT 克隆目标仓库（支持跨仓库访问，替换默认 token）
            TARGET_CLONE_URL="https://$GITHUB_ACTOR:$PERSONAL_ACCESS_TOKEN@github.com/$TARGET.git"
            git clone --mirror "$TARGET_CLONE_URL" target-repo-mirror
            cd target-repo-mirror
            
            # 2. 循环同步每个上游仓库到当前目标仓库
            for UPSTREAM in "${UPSTREAM_LIST[@]}"; do
              UPSTREAM=$(echo "$UPSTREAM" | xargs)
              echo "--------------------------------------"
              echo "Syncing $TARGET from upstream: $UPSTREAM"
              echo "--------------------------------------"
              
              # 添加上游仓库远程地址（带 PAT 保证访问权限）
              UPSTREAM_REMOTE="upstream-$UPSTREAM"
              UPSTREAM_URL="https://$GITHUB_ACTOR:$PERSONAL_ACCESS_TOKEN@github.com/$UPSTREAM.git"
              if git remote | grep -q "$UPSTREAM_REMOTE"; then
                git remote set-url "$UPSTREAM_REMOTE" "$UPSTREAM_URL"
              else
                git remote add "$UPSTREAM_REMOTE" "$UPSTREAM_URL"
              fi
              
              # 拉取上游仓库所有分支、标签（清理无效分支）
              git fetch "$UPSTREAM_REMOTE" --tags --prune
              
              # 获取上游所有分支并同步
              UPSTREAM_BRANCHES=$(git branch -r | grep "$UPSTREAM_REMOTE/" | grep -v HEAD | sed "s|$UPSTREAM_REMOTE/||g")
              for BRANCH in $UPSTREAM_BRANCHES; do
                echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
                echo "Syncing branch $BRANCH for $TARGET"
                echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
                
                # 切换/创建分支并同步
                if git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
                  git checkout "$BRANCH"
                else
                  git checkout -b "$BRANCH" "$UPSTREAM_REMOTE/$BRANCH"
                fi
                
                # 合并/强制同步上游分支
                if [[ "${{ github.event.inputs.force_sync }}" == "true" ]]; then
                  git reset --hard "$UPSTREAM_REMOTE/$BRANCH"
                  echo "Force synced branch $BRANCH"
                else
                  git merge --ff-only "$UPSTREAM_REMOTE/$BRANCH"
                  echo "Fast-forward merged branch $BRANCH"
                fi
              done
              
              # 3. 推送所有同步后的分支、标签到目标仓库（跨仓库推送，依赖 PAT 权限）
              git push --all origin
              git push --tags origin
            done
            
            # 退出镜像仓库目录，清理下一个目标仓库
            cd ..
            rm -rf target-repo-mirror
          done
          
          echo "======================================"
          echo "All repos and branches sync completed successfully!"
          echo "======================================"
